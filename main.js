/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/ui/ImageModal.ts
var ImageModal_exports = {};
__export(ImageModal_exports, {
  ImageModal: () => ImageModal
});
var import_obsidian4, ImageModal;
var init_ImageModal = __esm({
  "src/ui/ImageModal.ts"() {
    import_obsidian4 = require("obsidian");
    ImageModal = class extends import_obsidian4.Modal {
      constructor(app, client, imageManager, settings, initialPrompt) {
        super(app);
        this.client = client;
        this.imageManager = imageManager;
        this.settings = settings;
        this.initialPrompt = initialPrompt;
        this.isGenerating = false;
        if (initialPrompt) {
          this.promptField = new import_obsidian4.TextAreaComponent(document.createElement("textarea"));
          this.promptField.setValue(initialPrompt);
        }
      }
      async onOpen() {
        const { contentEl } = this;
        contentEl.addClass("nanogpt-image-modal");
        contentEl.createEl("h2", { text: "Generate Image" });
        contentEl.createEl("p", { text: "Describe the image you want to generate:" });
        this.promptField = new import_obsidian4.TextAreaComponent(contentEl).setPlaceholder("A beautiful sunset over the ocean...").onChange(() => this.adjustTextareaHeight());
        if (this.initialPrompt) {
          this.promptField.setValue(this.initialPrompt);
        }
        const optionsContainer = contentEl.createDiv({
          cls: "nanogpt-image-options"
        });
        optionsContainer.createEl("label", { text: "Model: " });
        const modelSelect = optionsContainer.createEl("select");
        modelSelect.createEl("option", { value: "", text: "Loading..." });
        modelSelect.disabled = true;
        this.client.listImageModels().then((models) => {
          modelSelect.empty();
          modelSelect.disabled = false;
          models.forEach((m) => {
            modelSelect.createEl("option", { value: m.model, text: m.name });
          });
          if (models.some((m) => m.model === "flux-pro")) {
            modelSelect.value = "flux-pro";
          }
        });
        optionsContainer.createEl("label", { text: " Size: " });
        const sizeSelect = optionsContainer.createEl("select");
        sizeSelect.createEl("option", { value: "256x256", text: "256x256" });
        sizeSelect.createEl("option", { value: "512x512", text: "512x512" });
        sizeSelect.createEl("option", { value: "1024x1024", text: "1024x1024" });
        sizeSelect.createEl("option", { value: "1536x1024", text: "1536x1024" });
        sizeSelect.createEl("option", { value: "1024x1536", text: "1024x1536" });
        sizeSelect.value = this.settings.imageSize;
        optionsContainer.createEl("label", { text: " Quality: " });
        const qualitySelect = optionsContainer.createEl("select");
        qualitySelect.createEl("option", { value: "standard", text: "Standard" });
        qualitySelect.createEl("option", { value: "hd", text: "HD" });
        qualitySelect.value = this.settings.imageQuality;
        const generateButton = contentEl.createEl("button", {
          text: "Generate",
          cls: "mod-cta"
        });
        generateButton.addEventListener("click", async () => {
          await this.generateImage(
            modelSelect.value,
            sizeSelect.value,
            qualitySelect.value
          );
        });
        this.resultContainer = contentEl.createDiv({
          cls: "nanogpt-image-result"
        });
        const closeButton = contentEl.createEl("button", { text: "Close" });
        closeButton.addEventListener("click", () => this.close());
      }
      async onClose() {
        const { contentEl } = this;
        contentEl.empty();
      }
      async generateImage(model, size, quality) {
        const prompt = this.promptField.getValue().trim();
        if (!prompt) {
          new import_obsidian4.Notice("Please enter a prompt");
          return;
        }
        if (this.isGenerating) return;
        this.isGenerating = true;
        this.resultContainer.empty();
        this.resultContainer.createEl("p", { text: "Generating image..." });
        try {
          const response = await this.client.generateImage({
            prompt,
            model,
            size,
            quality
          });
          this.resultContainer.empty();
          for (const imageData of response.data) {
            const imageDataUrl = imageData.b64_json ? `data:image/png;base64,${imageData.b64_json}` : imageData.url;
            const imgContainer = this.resultContainer.createDiv({
              cls: "nanogpt-image-item"
            });
            const img = imgContainer.createEl("img", {
              attr: { src: imageDataUrl || "" },
              cls: "nanogpt-generated-image"
            });
            const actions = imgContainer.createDiv({
              cls: "nanogpt-image-actions"
            });
            const insertButton = actions.createEl("button", {
              text: "Insert into Note",
              cls: "mod-cta"
            });
            insertButton.addEventListener("click", async () => {
              if (imageData.b64_json) {
                const markdownLink = await this.imageManager.saveImageToVault(
                  imageData.b64_json,
                  prompt
                );
                const activeView = this.app.workspace.getActiveViewOfType(import_obsidian4.MarkdownView);
                if (activeView) {
                  await this.imageManager.insertImageIntoEditor(
                    activeView.editor,
                    markdownLink
                  );
                  new import_obsidian4.Notice("Image inserted into note");
                }
              } else if (imageData.url) {
                new import_obsidian4.Notice("External image - please save manually");
              }
            });
            const saveButton = actions.createEl("button", {
              text: "Save to Vault"
            });
            saveButton.addEventListener("click", async () => {
              if (imageData.b64_json) {
                await this.imageManager.saveImageToVault(
                  imageData.b64_json,
                  prompt
                );
              }
            });
          }
        } catch (error) {
          console.error("Image generation error:", error);
          new import_obsidian4.Notice(`Error: ${error.message}`);
          this.resultContainer.createEl("p", {
            text: `Error: ${error.message}`,
            cls: "nanogpt-error"
          });
        } finally {
          this.isGenerating = false;
        }
      }
      adjustTextareaHeight() {
        const textarea = this.promptField.inputEl;
        textarea.style.height = "auto";
        textarea.style.height = Math.min(textarea.scrollHeight, 200) + "px";
      }
    };
  }
});

// src/ui/WebSearchModal.ts
var WebSearchModal_exports = {};
__export(WebSearchModal_exports, {
  WebSearchModal: () => WebSearchModal
});
var import_obsidian5, WebSearchModal;
var init_WebSearchModal = __esm({
  "src/ui/WebSearchModal.ts"() {
    import_obsidian5 = require("obsidian");
    WebSearchModal = class extends import_obsidian5.Modal {
      constructor(app, client, settings, initialQuery) {
        super(app);
        this.client = client;
        this.settings = settings;
        this.initialQuery = initialQuery;
        this.isSearching = false;
        this.component = new import_obsidian5.Component();
      }
      async onOpen() {
        const { contentEl } = this;
        contentEl.addClass("nanogpt-websearch-modal");
        contentEl.createEl("h2", { text: "Web Search" });
        this.queryField = new import_obsidian5.TextAreaComponent(contentEl).setPlaceholder("Search the web...").onChange(() => this.adjustTextareaHeight());
        if (this.initialQuery) {
          this.queryField.setValue(this.initialQuery);
        }
        const optionsContainer = contentEl.createDiv({
          cls: "nanogpt-websearch-options"
        });
        optionsContainer.createEl("label", { text: "Results: " });
        const numResultsSelect = optionsContainer.createEl("select");
        numResultsSelect.createEl("option", { value: "3", text: "3" });
        numResultsSelect.createEl("option", { value: "5", text: "5" });
        numResultsSelect.createEl("option", { value: "10", text: "10" });
        numResultsSelect.value = this.settings.webSearchNumResults.toString();
        const searchButton = contentEl.createEl("button", {
          text: "Search",
          cls: "mod-cta"
        });
        searchButton.addEventListener("click", async () => {
          await this.performSearch(parseInt(numResultsSelect.value));
        });
        this.resultContainer = contentEl.createDiv({
          cls: "nanogpt-websearch-result"
        });
        const closeButton = contentEl.createEl("button", { text: "Close" });
        closeButton.addEventListener("click", () => this.close());
      }
      async onClose() {
        this.component.unload();
        const { contentEl } = this;
        contentEl.empty();
      }
      async performSearch(numResults) {
        const query = this.queryField.getValue().trim();
        if (!query) {
          new import_obsidian5.Notice("Please enter a search query");
          return;
        }
        if (this.isSearching) return;
        this.isSearching = true;
        this.resultContainer.empty();
        this.resultContainer.createEl("p", { text: "Searching..." });
        try {
          const response = await this.client.webSearch({
            query,
            num_results: numResults,
            provider: this.settings.webSearchProvider,
            options: this.settings.webSearchOptions
          });
          this.resultContainer.empty();
          const markdown = this.formatWebSearchResults(response);
          const previewContainer = this.resultContainer.createDiv({
            cls: "nanogpt-websearch-preview"
          });
          await import_obsidian5.MarkdownRenderer.render(
            this.app,
            markdown,
            previewContainer,
            "",
            this.component
          );
          const insertButton = this.resultContainer.createEl("button", {
            text: "Insert into Note",
            cls: "mod-cta"
          });
          insertButton.addEventListener("click", () => {
            this.insertIntoNote(markdown);
          });
        } catch (error) {
          console.error("Web search error:", error);
          new import_obsidian5.Notice(`Error: ${error.message}`);
          this.resultContainer.createEl("p", {
            text: `Error: ${error.message}`,
            cls: "nanogpt-error"
          });
        } finally {
          this.isSearching = false;
        }
      }
      formatWebSearchResults(response) {
        let markdown = `## Web Search: "${response.query}"

`;
        markdown += `### Results

`;
        response.results.forEach((result, index) => {
          markdown += `${index + 1}. [${result.title}](${result.url})
`;
          markdown += `   ${result.summary}
`;
          if (result.source) {
            markdown += `   Source: ${result.source}
`;
          }
          markdown += "\n";
        });
        if (this.settings.includeCitations) {
          markdown += `### Citations

`;
          response.results.forEach((result, index) => {
            markdown += `- [${index + 1}] ${result.title} - ${result.url}
`;
          });
        }
        return markdown;
      }
      insertIntoNote(markdown) {
        const activeView = this.app.workspace.getActiveViewOfType(import_obsidian5.MarkdownView);
        if (activeView) {
          const editor = activeView.editor;
          const cursor = editor.getCursor();
          editor.replaceRange(`
${markdown}
`, cursor);
          new import_obsidian5.Notice("Web search results inserted");
          this.close();
        } else {
          new import_obsidian5.Notice("No active markdown note open");
        }
      }
      renderMarkdownToHTML(markdown) {
        return markdown.replace(/^### (.*$)/gim, "<h3>$1</h3>").replace(/^## (.*$)/gim, "<h2>$1</h2>").replace(/^- (.*$)/gim, "<li>$1</li>").replace(/^\d+\. \[(.*?)\]\((.*?)\)/gim, '<li><strong><a href="$2" target="_blank">$1</a></strong></li>').replace(/^   (.*$)/gim, "<blockquote>$1</blockquote>").replace(/\n\n/g, "</p><p>").replace(/\n/g, "<br>");
      }
      adjustTextareaHeight() {
        const textarea = this.queryField.inputEl;
        textarea.style.height = "auto";
        textarea.style.height = Math.min(textarea.scrollHeight, 200) + "px";
      }
    };
  }
});

// src/ui/EditNoteModal.ts
var EditNoteModal_exports = {};
__export(EditNoteModal_exports, {
  EditNoteModal: () => EditNoteModal
});
var import_obsidian6, EditNoteModal;
var init_EditNoteModal = __esm({
  "src/ui/EditNoteModal.ts"() {
    import_obsidian6 = require("obsidian");
    EditNoteModal = class extends import_obsidian6.Modal {
      constructor(app, client, settings, file) {
        super(app);
        this.client = client;
        this.settings = settings;
        this.file = file;
        this.isGenerating = false;
        this.proposedContent = "";
        this.component = new import_obsidian6.Component();
      }
      async onOpen() {
        const { contentEl } = this;
        contentEl.addClass("nanogpt-edit-modal");
        contentEl.createEl("h2", { text: "Edit Note with AI" });
        contentEl.createEl("p", { text: "Describe the edits you want to apply:" });
        this.instructionField = new import_obsidian6.TextAreaComponent(contentEl).setPlaceholder("Make the intro more concise and add a summary section...").onChange(() => this.adjustTextareaHeight());
        const controls = contentEl.createDiv({ cls: "nanogpt-edit-controls" });
        const generateButton = controls.createEl("button", {
          text: "Generate Preview",
          cls: "mod-cta"
        });
        generateButton.addEventListener("click", async () => {
          await this.generatePreview();
        });
        this.applyButton = controls.createEl("button", {
          text: "Apply Changes",
          cls: "mod-cta"
        });
        this.applyButton.disabled = true;
        this.applyButton.addEventListener("click", async () => {
          await this.applyChanges();
        });
        this.resultContainer = contentEl.createDiv({
          cls: "nanogpt-edit-preview"
        });
        const closeButton = contentEl.createEl("button", { text: "Close" });
        closeButton.addEventListener("click", () => this.close());
      }
      async onClose() {
        this.component.unload();
        const { contentEl } = this;
        contentEl.empty();
      }
      async getFolderContext() {
        var _a, _b;
        if (!this.settings.folderContextEnabled) return "";
        const folderPath = (_b = (_a = this.file.parent) == null ? void 0 : _a.path) != null ? _b : "";
        const files = this.app.vault.getMarkdownFiles().filter((file) => {
          var _a2;
          if (file.path === this.file.path) return false;
          return ((_a2 = file.parent) == null ? void 0 : _a2.path) === folderPath;
        });
        if (files.length === 0) return "";
        const contextEntries = [];
        let totalChars = 0;
        let fileCount = 0;
        for (const file of files) {
          if (fileCount >= this.settings.folderContextMaxFiles) break;
          try {
            const content = await this.app.vault.read(file);
            if (!content) continue;
            const nextEntry = `
---
File: ${file.basename}
${content}
`;
            if (totalChars + nextEntry.length > this.settings.folderContextMaxChars) break;
            contextEntries.push(nextEntry);
            totalChars += nextEntry.length;
            fileCount += 1;
          } catch (error) {
            console.warn("Failed to read file for folder context", error);
          }
        }
        if (contextEntries.length === 0) return "";
        return `

Context from notes in folder "${folderPath || "/"}":
${contextEntries.join("")}`;
      }
      async generatePreview() {
        const instructions = this.instructionField.getValue().trim();
        if (!instructions) {
          new import_obsidian6.Notice("Please enter edit instructions");
          return;
        }
        if (this.isGenerating) return;
        this.isGenerating = true;
        this.resultContainer.empty();
        this.resultContainer.createEl("p", { text: "Generating preview..." });
        try {
          const originalContent = await this.app.vault.read(this.file);
          const folderContext = await this.getFolderContext();
          const systemPrompt = "You are an assistant that edits Obsidian notes. Return the full revised note in Markdown only.";
          const userPrompt = `Edit instructions:
${instructions}

Original note:
${originalContent}${folderContext}`;
          let updatedContent = "";
          await this.client.streamChatCompletion(
            [
              { role: "system", content: systemPrompt },
              { role: "user", content: userPrompt }
            ],
            this.settings.defaultModel,
            (chunk) => {
              updatedContent += chunk;
            },
            this.settings.temperature,
            this.settings.maxTokens
          );
          this.proposedContent = updatedContent.trim();
          this.applyButton.disabled = this.proposedContent.length === 0;
          this.resultContainer.empty();
          await import_obsidian6.MarkdownRenderer.render(
            this.app,
            this.proposedContent,
            this.resultContainer,
            this.file.path,
            this.component
          );
        } catch (error) {
          console.error("Edit note error:", error);
          new import_obsidian6.Notice(`Error: ${error.message}`);
          this.resultContainer.createEl("p", {
            text: `Error: ${error.message}`,
            cls: "nanogpt-error"
          });
        } finally {
          this.isGenerating = false;
        }
      }
      async applyChanges() {
        if (!this.proposedContent) return;
        try {
          await this.app.vault.modify(this.file, this.proposedContent);
          new import_obsidian6.Notice("Note updated");
          this.close();
        } catch (error) {
          console.error("Apply edit error:", error);
          new import_obsidian6.Notice(`Error: ${error.message}`);
        }
      }
      adjustTextareaHeight() {
        const textarea = this.instructionField.inputEl;
        textarea.style.height = "auto";
        textarea.style.height = Math.min(textarea.scrollHeight, 200) + "px";
      }
    };
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => NanoGPTPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian7 = require("obsidian");
var import_view = require("@codemirror/view");
var import_state = require("@codemirror/state");

// src/api/NanoGPTClient.ts
var NanoGPTClient = class {
  // 5 minutes
  constructor(apiKey, baseUrl = "https://nano-gpt.com/api/v1") {
    this.modelCache = /* @__PURE__ */ new Map();
    this.imageModelCache = null;
    this.CACHE_DURATION = 5 * 60 * 1e3;
    this.apiKey = apiKey;
    this.baseUrl = baseUrl;
  }
  setApiKey(apiKey) {
    this.apiKey = apiKey;
  }
  setBaseUrl(baseUrl) {
    this.baseUrl = baseUrl;
  }
  async fetchWithAuth(url, options = {}) {
    if (!this.apiKey) {
      throw new Error("API key is required");
    }
    const response = await fetch(url, {
      ...options,
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${this.apiKey}`,
        ...options.headers
      }
    });
    if (!response.ok) {
      const error = await response.text();
      throw new Error(`NanoGPT API error: ${response.status} - ${error}`);
    }
    return response;
  }
  async streamChatCompletion(messages, model, onChunk, temperature = 0.7, maxTokens = 2048) {
    var _a, _b, _c;
    const request = {
      model,
      messages,
      stream: true,
      temperature,
      max_tokens: maxTokens
    };
    const response = await this.fetchWithAuth(`${this.baseUrl}/chat/completions`, {
      method: "POST",
      body: JSON.stringify(request)
    });
    const reader = (_a = response.body) == null ? void 0 : _a.getReader();
    if (!reader) {
      throw new Error("No response body");
    }
    const decoder = new TextDecoder();
    let buffer = "";
    try {
      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        buffer += decoder.decode(value, { stream: true });
        const lines = buffer.split("\n");
        buffer = lines.pop() || "";
        for (const line of lines) {
          const trimmedLine = line.trim();
          if (trimmedLine === "" || trimmedLine === "data: [DONE]") continue;
          if (!trimmedLine.startsWith("data: ")) continue;
          try {
            const jsonStr = trimmedLine.slice(6);
            const chunk = JSON.parse(jsonStr);
            const content = (_c = (_b = chunk.choices[0]) == null ? void 0 : _b.delta) == null ? void 0 : _c.content;
            if (content) {
              onChunk(content);
            }
          } catch (e) {
            console.error("Error parsing SSE chunk:", e);
          }
        }
      }
    } finally {
      reader.releaseLock();
    }
  }
  async generateImage(request) {
    const body = {
      prompt: request.prompt,
      model: request.model || "flux-pro",
      n: request.n || 1,
      size: request.size || "1024x1024",
      quality: request.quality || "standard"
    };
    const response = await this.fetchWithAuth(`${this.baseUrl}/images/generations`, {
      method: "POST",
      body: JSON.stringify(body)
    });
    return await response.json();
  }
  async webSearch(request) {
    let parsedOptions;
    if (typeof request.options === "string" && request.options.trim().length > 0) {
      try {
        parsedOptions = JSON.parse(request.options);
      } catch (error) {
        console.warn("Invalid web search options JSON, ignoring.", error);
      }
    } else if (request.options && typeof request.options === "object") {
      parsedOptions = request.options;
    }
    const body = {
      query: request.query,
      num_results: request.num_results,
      provider: request.provider || void 0,
      options: parsedOptions
    };
    const endpoint = this.baseUrl.replace("/v1", "/web");
    const response = await this.fetchWithAuth(endpoint, {
      method: "POST",
      body: JSON.stringify(body)
    });
    return await response.json();
  }
  async listImageModels() {
    var _a;
    if (this.imageModelCache && Date.now() - this.imageModelCache.timestamp < this.CACHE_DURATION) {
      return this.imageModelCache.models;
    }
    try {
      const response = await this.fetchWithAuth("https://nano-gpt.com/api/models/image");
      const data = await response.json();
      const models = [];
      const imageModels = ((_a = data.models) == null ? void 0 : _a.image) || data.models || data.data || [];
      if (Array.isArray(imageModels)) {
        imageModels.forEach((modelData) => {
          const modelId = modelData.model || modelData.id || modelData.name;
          if (!modelId) return;
          models.push({
            model: modelId,
            name: modelData.name || modelId,
            description: modelData.description,
            engine: modelData.engine
          });
        });
      } else if (imageModels && typeof imageModels === "object") {
        for (const [key, value] of Object.entries(imageModels)) {
          const modelData = value;
          models.push({
            model: modelData.model || modelData.id || key,
            name: modelData.name || key,
            description: modelData.description,
            engine: modelData.engine
          });
        }
      }
      this.imageModelCache = {
        models,
        timestamp: Date.now()
      };
      return models;
    } catch (e) {
      console.error("Failed to fetch image models", e);
      return [
        { model: "flux-pro", name: "Flux Pro" },
        { model: "dall-e-3", name: "DALL-E 3" },
        { model: "stable-diffusion-xl", name: "Stable Diffusion XL" }
      ];
    }
  }
  async scrapeUrls(request) {
    const response = await this.fetchWithAuth("https://nano-gpt.com/api/scrape-urls", {
      method: "POST",
      body: JSON.stringify(request)
    });
    return await response.json();
  }
  async listModels(subscriptionOnly = false) {
    const cacheKey = subscriptionOnly ? "subscription" : "all";
    const cached = this.modelCache.get(cacheKey);
    if (cached && Date.now() - cached.timestamp < this.CACHE_DURATION) {
      return cached.models;
    }
    let models = [];
    try {
      let baseEndpoint = this.baseUrl;
      if (subscriptionOnly) {
        if (this.baseUrl.includes("/subscription/")) {
          baseEndpoint = this.baseUrl;
        } else if (/\/v1\/?$/.test(this.baseUrl)) {
          baseEndpoint = this.baseUrl.replace(/\/v1\/?$/, "/subscription/v1");
        } else {
          baseEndpoint = `${this.baseUrl.replace(/\/$/, "")}/subscription/v1`;
        }
      }
      const response = await this.fetchWithAuth(`${baseEndpoint}/models`);
      const data = await response.json();
      models = data.data || [];
    } catch (e) {
      console.error("Failed to fetch models", e);
      return [
        { id: "zai-org/glm-4.7", object: "model", name: "GLM 4.7" },
        { id: "gpt-4o", object: "model", name: "GPT-4o" },
        { id: "claude-3-5-sonnet-20240620", object: "model", name: "Claude 3.5 Sonnet" }
      ];
    }
    this.modelCache.set(cacheKey, {
      models,
      timestamp: Date.now()
    });
    return models;
  }
  async checkBalance() {
    const response = await this.fetchWithAuth(`${this.baseUrl}/check-balance`, {
      method: "GET"
    });
    const data = await response.json();
    return data.balance || 0;
  }
  invalidateCache() {
    this.modelCache.clear();
    this.imageModelCache = null;
  }
};

// src/storage/ChatHistoryManager.ts
var ChatHistoryManager = class {
  constructor(app, plugin) {
    this.app = app;
    this.plugin = plugin;
    this.history = {};
    this.loaded = false;
  }
  async ensureLoaded() {
    if (this.loaded) return;
    this.history = this.plugin.settings.chatHistory || {};
    this.loaded = true;
  }
  async loadChatHistory(file) {
    await this.ensureLoaded();
    return this.history[file.path] || [];
  }
  async saveChatHistory(file, messages) {
    await this.ensureLoaded();
    this.history[file.path] = messages;
    this.plugin.settings.chatHistory = this.history;
    await this.plugin.saveData(this.plugin.settings);
  }
  async appendMessage(file, message) {
    const messages = await this.loadChatHistory(file);
    messages.push(message);
    await this.saveChatHistory(file, messages);
  }
  async clearChatHistory(file) {
    await this.saveChatHistory(file, []);
  }
};

// src/storage/ImageManager.ts
var import_obsidian = require("obsidian");
var import_node_crypto = require("node:crypto");
var ImageManager = class {
  constructor(app) {
    this.app = app;
  }
  async saveImageToVault(base64Data, prompt) {
    try {
      const buffer = Buffer.from(base64Data, "base64");
      const uint8Array = new Uint8Array(buffer);
      const extension = "png";
      const timestamp = Date.now();
      const hash = this.generateShortHash(prompt);
      const filename = `nanogpt-${timestamp}-${hash}.${extension}`;
      const path = await this.app.fileManager.getAvailablePathForAttachment(filename);
      await this.app.vault.createBinary(path, uint8Array.buffer);
      const markdownLink = `![[${filename}]]`;
      new import_obsidian.Notice(`Image saved to: ${path}`);
      return markdownLink;
    } catch (error) {
      console.error("Error saving image:", error);
      new import_obsidian.Notice("Failed to save image to vault");
      throw error;
    }
  }
  generateShortHash(prompt) {
    const hash = (0, import_node_crypto.createHash)("md5").update(prompt).digest("hex");
    return hash.substring(0, 8);
  }
  async insertImageIntoEditor(editor, markdownLink) {
    editor.replaceRange(`
${markdownLink}
`, editor.getCursor());
  }
};

// src/api/types.ts
var DEFAULT_SETTINGS = {
  apiKey: "",
  baseUrl: "https://nano-gpt.com/api/v1",
  defaultModel: "zai-org/glm-4.7",
  subscriptionOnly: true,
  systemPrompt: "You are a helpful AI assistant.",
  temperature: 0.7,
  maxTokens: 2048,
  inlineAutocompleteEnabled: false,
  inlineAutocompleteDelayMs: 700,
  folderContextEnabled: true,
  folderContextMaxFiles: 5,
  folderContextMaxChars: 8e3,
  imageSize: "1024x1024",
  imageQuality: "standard",
  webSearchNumResults: 5,
  webSearchProvider: "",
  webSearchOptions: "",
  includeCitations: true,
  chatHistory: {}
};

// src/ui/ChatView.ts
var import_obsidian3 = require("obsidian");

// src/ui/ModelPicker.ts
var import_obsidian2 = require("obsidian");
var ModelPicker = class {
  constructor(containerEl, initialModelId, onSelect) {
    this.dropdownEl = null;
    this.models = [];
    this.containerEl = containerEl;
    this.selectedModelId = initialModelId;
    this.onSelect = onSelect;
    this.render();
  }
  setModels(models) {
    this.models = models;
  }
  render() {
    this.buttonEl = this.containerEl.createEl("button", {
      cls: "nanogpt-model-picker-btn"
    });
    this.updateButtonText();
    this.buttonEl.addEventListener("click", (e) => {
      e.stopPropagation();
      this.toggleDropdown();
    });
    document.addEventListener("click", (e) => {
      if (this.dropdownEl && !this.dropdownEl.contains(e.target) && !this.buttonEl.contains(e.target)) {
        this.closeDropdown();
      }
    });
  }
  updateButtonText() {
    if (!this.buttonEl) return;
    this.buttonEl.empty();
    const selectedModel = this.models.find((m) => m.id === this.selectedModelId);
    const modelName = (selectedModel == null ? void 0 : selectedModel.name) || this.selectedModelId;
    this.buttonEl.createSpan({ text: modelName, cls: "nanogpt-model-name" });
    if ((selectedModel == null ? void 0 : selectedModel.kind) === "image") {
      this.buttonEl.createSpan({ text: "Image", cls: "nanogpt-model-badge" });
    }
    const iconSpan = this.buttonEl.createSpan({ cls: "nanogpt-picker-icon" });
    (0, import_obsidian2.setIcon)(iconSpan, "chevron-down");
  }
  toggleDropdown() {
    if (this.dropdownEl) {
      this.closeDropdown();
    } else {
      this.openDropdown();
    }
  }
  openDropdown() {
    const parentRect = this.containerEl.getBoundingClientRect();
    this.dropdownEl = document.body.createDiv({
      cls: "nanogpt-model-picker-dropdown"
    });
    this.dropdownEl.style.top = `${parentRect.bottom + 5}px`;
    this.dropdownEl.style.left = `${parentRect.left}px`;
    const searchContainer = this.dropdownEl.createDiv({ cls: "nanogpt-model-search" });
    const searchInput = searchContainer.createEl("input", {
      attr: { type: "text", placeholder: "Search models..." }
    });
    searchInput.focus();
    const listContainer = this.dropdownEl.createDiv({ cls: "nanogpt-model-list" });
    this.renderModelList(listContainer, this.models);
    searchInput.addEventListener("input", (e) => {
      const query = e.target.value.toLowerCase();
      const filtered = this.models.filter(
        (m) => m.id.toLowerCase().includes(query) || m.name && m.name.toLowerCase().includes(query)
      );
      this.renderModelList(listContainer, filtered);
    });
  }
  renderModelList(container, models) {
    container.empty();
    if (models.length === 0) {
      container.createDiv({
        text: "No models found",
        attr: { style: "padding: 8px 12px; color: var(--text-muted); font-size: 0.8rem;" }
      });
      return;
    }
    models.forEach((model) => {
      const item = container.createDiv({
        cls: `nanogpt-model-item ${model.id === this.selectedModelId ? "selected" : ""}`
      });
      const nameRow = item.createDiv({ cls: "nanogpt-model-item-header" });
      nameRow.createSpan({ text: model.name || model.id, cls: "nanogpt-model-item-name" });
      if (model.kind === "image") {
        nameRow.createSpan({ text: "Image", cls: "nanogpt-model-badge" });
      }
      if (model.description) {
        item.createDiv({ text: model.description, cls: "nanogpt-model-item-desc" });
      }
      item.addEventListener("click", () => {
        this.selectedModelId = model.id;
        this.updateButtonText();
        this.onSelect(model.id);
        this.closeDropdown();
      });
    });
  }
  closeDropdown() {
    if (this.dropdownEl) {
      this.dropdownEl.remove();
      this.dropdownEl = null;
    }
  }
};

// src/ui/ChatView.ts
var VIEW_TYPE_CHAT = "nanogpt-chat-view";
var ChatView = class extends import_obsidian3.ItemView {
  constructor(leaf, client, chatHistoryManager, settings) {
    super(leaf);
    this.client = client;
    this.chatHistoryManager = chatHistoryManager;
    this.settings = settings;
    this.messages = [];
    this.isGenerating = false;
    this.activeFile = null;
    this.webSearchEnabled = false;
    this.imageModelIds = /* @__PURE__ */ new Set();
    this.chatMode = "ask";
    this.pendingEditPreview = null;
    this.currentModel = settings.defaultModel;
  }
  getViewType() {
    return VIEW_TYPE_CHAT;
  }
  getDisplayText() {
    return "NanoGPT Chat";
  }
  getIcon() {
    return "sparkles";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("nanogpt-chat-view");
    const header = container.createDiv({ cls: "nanogpt-header" });
    const modelPickerContainer = header.createDiv({ cls: "nanogpt-model-picker-container" });
    this.modelPicker = new ModelPicker(modelPickerContainer, this.currentModel, (modelId) => {
      this.currentModel = modelId;
      new import_obsidian3.Notice(`Model changed to ${modelId}`);
    });
    const modeToggle = header.createDiv({ cls: "nanogpt-chat-mode-toggle" });
    const askModeButton = modeToggle.createEl("button", {
      text: "Ask",
      cls: "nanogpt-mode-btn is-active"
    });
    const editModeButton = modeToggle.createEl("button", {
      text: "Edit",
      cls: "nanogpt-mode-btn"
    });
    const setMode = (mode) => {
      this.chatMode = mode;
      if (mode === "ask") {
        askModeButton.addClass("is-active");
        editModeButton.removeClass("is-active");
      } else {
        editModeButton.addClass("is-active");
        askModeButton.removeClass("is-active");
      }
      new import_obsidian3.Notice(`Chat mode: ${mode === "ask" ? "Ask" : "Edit"}`);
    };
    askModeButton.addEventListener("click", () => setMode("ask"));
    editModeButton.addEventListener("click", () => setMode("edit"));
    this.loadModels();
    const actionsContainer = header.createDiv({ cls: "nanogpt-header-actions" });
    const webSearchBtn = actionsContainer.createEl("button", {
      cls: "nanogpt-icon-btn",
      attr: { "aria-label": "Toggle Web Search" }
    });
    (0, import_obsidian3.setIcon)(webSearchBtn, "globe");
    webSearchBtn.addEventListener("click", () => {
      this.webSearchEnabled = !this.webSearchEnabled;
      if (this.webSearchEnabled) {
        webSearchBtn.addClass("is-active");
        new import_obsidian3.Notice("Web Search enabled");
      } else {
        webSearchBtn.removeClass("is-active");
        new import_obsidian3.Notice("Web Search disabled");
      }
    });
    const newChatBtn = actionsContainer.createEl("button", {
      cls: "nanogpt-icon-btn",
      attr: { "aria-label": "Clear Chat" }
    });
    (0, import_obsidian3.setIcon)(newChatBtn, "plus-circle");
    newChatBtn.addEventListener("click", () => this.clearChat());
    this.chatContainer = container.createDiv({
      cls: "nanogpt-chat-container"
    });
    const inputContainer = container.createDiv({
      cls: "nanogpt-input-container"
    });
    const inputWrapper = inputContainer.createDiv({
      cls: "nanogpt-input-wrapper"
    });
    this.inputField = new import_obsidian3.TextAreaComponent(inputWrapper).setPlaceholder("Message NanoGPT...").onChange(() => this.adjustInputHeight());
    this.inputField.inputEl.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        this.sendMessage();
      }
    });
    const inputFooter = inputWrapper.createDiv({ cls: "nanogpt-input-footer" });
    const contextIndicator = inputFooter.createDiv({ cls: "nanogpt-context-indicator" });
    (0, import_obsidian3.setIcon)(contextIndicator.createSpan(), "file-text");
    const contextText = contextIndicator.createSpan({ text: "No file" });
    this.sendButton = inputFooter.createEl("button", {
      text: "Send",
      cls: "nanogpt-send-btn"
    });
    this.sendButton.addEventListener("click", () => this.sendMessage());
    this.registerEvent(
      this.app.workspace.on("file-open", async (file2) => {
        this.activeFile = file2;
        contextText.setText(file2 ? file2.basename : "No file");
        await this.onActiveFileChange(file2);
      })
    );
    const file = this.app.workspace.getActiveFile();
    this.activeFile = file;
    contextText.setText(file ? file.basename : "No file");
    await this.onActiveFileChange(file);
  }
  async onClose() {
  }
  async loadModels() {
    try {
      const [models, imageModels] = await Promise.all([
        this.client.listModels(this.settings.subscriptionOnly),
        this.client.listImageModels()
      ]);
      this.imageModelIds = new Set(imageModels.map((model) => model.model));
      const chatModels = models.map((model) => ({
        ...model,
        kind: model.kind || "chat"
      }));
      const imageAsModels = imageModels.map((model) => ({
        id: model.model,
        object: "model",
        name: model.name,
        description: model.description || "Image generation model",
        kind: "image"
      }));
      this.modelPicker.setModels([...chatModels, ...imageAsModels]);
    } catch (error) {
      console.error("Failed to load models:", error);
    }
  }
  async onActiveFileChange(file) {
    if (file) {
      await this.loadChatHistory();
      await this.renderMessages();
      if (this.inputField) this.inputField.setDisabled(false);
      if (this.sendButton) this.sendButton.disabled = false;
    } else {
      this.chatContainer.empty();
      const emptyState = this.chatContainer.createDiv({ cls: "nanogpt-empty-state" });
      (0, import_obsidian3.setIcon)(emptyState.createDiv(), "file-question");
      emptyState.createDiv({ text: "Open a note to start a conversation." });
      if (this.inputField) this.inputField.setDisabled(true);
      if (this.sendButton) this.sendButton.disabled = true;
    }
  }
  async loadChatHistory() {
    if (this.activeFile) {
      this.messages = await this.chatHistoryManager.loadChatHistory(this.activeFile);
    } else {
      this.messages = [];
    }
  }
  async renderMessages() {
    this.chatContainer.empty();
    if (!this.activeFile) return;
    if (this.messages.length === 0) {
      const emptyState = this.chatContainer.createDiv({ cls: "nanogpt-empty-state" });
      (0, import_obsidian3.setIcon)(emptyState.createDiv(), "message-square");
      emptyState.createDiv({ text: "Start a new thread." });
      return;
    }
    for (const msg of this.messages) {
      await this.appendMessageToUI(msg.role, msg.content);
    }
    this.scrollToBottom();
  }
  async appendMessageToUI(role, content) {
    var _a;
    const messageEl = this.chatContainer.createDiv({
      cls: `nanogpt-message nanogpt-${role}`
    });
    if (role !== "user") {
      const headerDiv = messageEl.createDiv({ cls: "nanogpt-message-header" });
      headerDiv.createSpan({ text: "NanoGPT", cls: "nanogpt-message-role" });
      const actionsDiv = headerDiv.createDiv({ cls: "nanogpt-message-actions" });
      const copyBtn = actionsDiv.createEl("button", { cls: "nanogpt-msg-btn", attr: { "aria-label": "Copy" } });
      (0, import_obsidian3.setIcon)(copyBtn, "copy");
      copyBtn.addEventListener("click", () => {
        navigator.clipboard.writeText(content);
        new import_obsidian3.Notice("Copied to clipboard");
      });
      const insertBtn = actionsDiv.createEl("button", { cls: "nanogpt-msg-btn", attr: { "aria-label": "Insert at Cursor" } });
      (0, import_obsidian3.setIcon)(insertBtn, "arrow-down-to-line");
      insertBtn.addEventListener("click", () => this.insertContentIntoNote(content));
    }
    const contentEl = messageEl.createDiv({
      cls: "nanogpt-message-content"
    });
    await import_obsidian3.MarkdownRenderer.render(
      this.app,
      content,
      contentEl,
      ((_a = this.activeFile) == null ? void 0 : _a.path) || "",
      this
    );
    if (role !== "user" && this.pendingEditPreview) {
      const preview = this.pendingEditPreview;
      this.pendingEditPreview = null;
      const controls = contentEl.createDiv({ cls: "nanogpt-edit-inline-controls" });
      const acceptBtn = controls.createEl("button", { text: "Accept", cls: "mod-cta" });
      const rejectBtn = controls.createEl("button", { text: "Reject" });
      acceptBtn.addEventListener("click", async () => {
        await this.app.vault.modify(preview.file, preview.updated);
        new import_obsidian3.Notice("Edits applied");
      });
      rejectBtn.addEventListener("click", () => {
        new import_obsidian3.Notice("Edits rejected");
      });
    }
  }
  insertContentIntoNote(content) {
    let view = this.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
    if (!view || this.activeFile && (!view.file || view.file.path !== this.activeFile.path)) {
      const leaves = this.app.workspace.getLeavesOfType("markdown");
      const matchingLeaf = leaves.find(
        (leaf) => {
          var _a, _b;
          return ((_a = leaf.view.file) == null ? void 0 : _a.path) === ((_b = this.activeFile) == null ? void 0 : _b.path);
        }
      );
      if (matchingLeaf) {
        view = matchingLeaf.view;
        this.app.workspace.setActiveLeaf(matchingLeaf, { focus: true });
      }
    }
    if (view) {
      const editor = view.editor;
      editor.focus();
      editor.replaceSelection(content);
      new import_obsidian3.Notice("Inserted into note");
    } else {
      new import_obsidian3.Notice("Could not find editor for this note");
    }
  }
  formatMessageContent(content) {
    return content.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\n/g, "<br>").replace(/\*\*(.*?)\*\*/g, "<strong>$1</strong>").replace(/\*(.*?)\*/g, "<em>$1</em>").replace(/`(.*?)`/g, "<code>$1</code>");
  }
  async getNoteContent() {
    if (!this.activeFile) return "";
    try {
      return await this.app.vault.read(this.activeFile);
    } catch (error) {
      console.error("Error reading note content:", error);
      return "";
    }
  }
  async getFolderContext() {
    var _a, _b;
    if (!this.activeFile) return "";
    if (!this.settings.folderContextEnabled) return "";
    const folderPath = (_b = (_a = this.activeFile.parent) == null ? void 0 : _a.path) != null ? _b : "";
    const files = this.app.vault.getMarkdownFiles().filter((file) => {
      var _a2, _b2;
      if (file.path === ((_a2 = this.activeFile) == null ? void 0 : _a2.path)) return false;
      return ((_b2 = file.parent) == null ? void 0 : _b2.path) === folderPath;
    });
    if (files.length === 0) return "";
    const contextEntries = [];
    let totalChars = 0;
    let fileCount = 0;
    for (const file of files) {
      if (fileCount >= this.settings.folderContextMaxFiles) break;
      try {
        const content = await this.app.vault.read(file);
        if (!content) continue;
        const nextEntry = `
---
File: ${file.basename}
${content}
`;
        if (totalChars + nextEntry.length > this.settings.folderContextMaxChars) break;
        contextEntries.push(nextEntry);
        totalChars += nextEntry.length;
        fileCount += 1;
      } catch (error) {
        console.warn("Failed to read file for folder context", error);
      }
    }
    if (contextEntries.length === 0) return "";
    return `

Context from notes in folder "${folderPath || "/"}":
${contextEntries.join("")}`;
  }
  extractUrls(text) {
    var _a;
    const regex = /(https?:\/\/[^\s)\]]+)/g;
    const urls = /* @__PURE__ */ new Set();
    let match;
    while ((match = regex.exec(text)) !== null) {
      const url = (_a = match[1]) == null ? void 0 : _a.trim();
      if (url) urls.add(url);
    }
    return Array.from(urls).slice(0, 5);
  }
  async confirmScrapeUrls(urls) {
    return new Promise((resolve) => {
      const modal = new import_obsidian3.Modal(this.app);
      modal.contentEl.addClass("nanogpt-edit-modal");
      modal.contentEl.createEl("h2", { text: "Scrape URLs?" });
      modal.contentEl.createEl("p", {
        text: "This will scrape the URL(s) and create notes. Continue?"
      });
      const list = modal.contentEl.createEl("ul");
      urls.forEach((url) => {
        list.createEl("li", { text: url });
      });
      const actions = modal.contentEl.createDiv({ cls: "nanogpt-edit-controls" });
      const confirmBtn = actions.createEl("button", { text: "Scrape", cls: "mod-cta" });
      const cancelBtn = actions.createEl("button", { text: "Cancel" });
      const finish = (value) => {
        resolve(value);
        modal.close();
      };
      confirmBtn.addEventListener("click", () => finish(true));
      cancelBtn.addEventListener("click", () => finish(false));
      modal.onClose = () => resolve(false);
      modal.open();
    });
  }
  parseCreateNotesCommand(text) {
    const trimmed = text.trim();
    const match = trimmed.match(/^create\s+notes?:\s*(.+)$/i);
    if (!match) return [];
    const payload = match[1];
    return payload.split(/[\n,;]/).map((title) => title.trim()).filter(Boolean);
  }
  async getUniqueNotePath(folderPath, title) {
    const safeTitle = title.replace(/[\\/:*?"<>|]/g, "").trim() || "Untitled";
    const basePath = (0, import_obsidian3.normalizePath)(folderPath ? `${folderPath}/${safeTitle}` : safeTitle);
    let candidate = `${basePath}.md`;
    let index = 1;
    while (this.app.vault.getAbstractFileByPath(candidate)) {
      candidate = `${basePath} (${index}).md`;
      index += 1;
    }
    return candidate;
  }
  getChatModelId() {
    return this.imageModelIds.has(this.currentModel) ? this.settings.defaultModel : this.currentModel;
  }
  async createNotesWithLinks(titles, contextNote) {
    var _a, _b, _c;
    const folderPath = (_b = (_a = contextNote.parent) == null ? void 0 : _a.path) != null ? _b : "";
    const createdPaths = [];
    const chatModelId = this.getChatModelId();
    for (const title of titles) {
      const notePath = await this.getUniqueNotePath(folderPath, title);
      const noteTitle = ((_c = notePath.split("/").pop()) == null ? void 0 : _c.replace(/\.md$/, "")) || title;
      const systemPrompt = "You are a helpful assistant that writes concise Obsidian notes in Markdown format.";
      const userPrompt = `Write an Obsidian note titled "${noteTitle}".`;
      let content = "";
      await this.client.streamChatCompletion(
        [
          { role: "system", content: systemPrompt },
          { role: "user", content: userPrompt }
        ],
        chatModelId,
        (chunk) => {
          content += chunk;
        },
        this.settings.temperature,
        Math.min(this.settings.maxTokens, 1200)
      );
      const finalContent = content.trim() || `# ${noteTitle}
`;
      await this.app.vault.create(notePath, finalContent);
      createdPaths.push(notePath);
    }
    if (createdPaths.length > 0) {
      const links = createdPaths.map((path) => `- [[${path.replace(/\.md$/, "").split("/").pop()}]]`).join("\n");
      const sectionHeader = "\n\n## Related Notes\n";
      const currentContent = await this.app.vault.read(contextNote);
      const updatedContent = currentContent.includes("## Related Notes") ? `${currentContent}
${links}` : `${currentContent}${sectionHeader}${links}`;
      await this.app.vault.modify(contextNote, updatedContent);
    }
    return createdPaths;
  }
  async createNotesFromScrape(urls, contextNote) {
    var _a, _b, _c;
    const response = await this.client.scrapeUrls({ urls });
    const successful = response.results.filter((result) => result.success);
    if (successful.length === 0) {
      return [];
    }
    const folderPath = (_b = (_a = contextNote.parent) == null ? void 0 : _a.path) != null ? _b : "";
    const createdPaths = [];
    for (const result of successful) {
      const title = result.title || result.url;
      const notePath = await this.getUniqueNotePath(folderPath, title);
      const noteTitle = ((_c = notePath.split("/").pop()) == null ? void 0 : _c.replace(/\.md$/, "")) || title;
      const body = result.markdown || result.content || "";
      const content = `# ${noteTitle}

Source: ${result.url}

${body}`;
      await this.app.vault.create(notePath, content.trim());
      createdPaths.push(notePath);
    }
    if (createdPaths.length > 0) {
      const links = createdPaths.map((path) => `- [[${path.replace(/\.md$/, "").split("/").pop()}]]`).join("\n");
      const sectionHeader = "\n\n## Web Scrapes\n";
      const currentContent = await this.app.vault.read(contextNote);
      const updatedContent = currentContent.includes("## Web Scrapes") ? `${currentContent}
${links}` : `${currentContent}${sectionHeader}${links}`;
      await this.app.vault.modify(contextNote, updatedContent);
    }
    return createdPaths;
  }
  async sendMessage() {
    const userMessage = this.inputField.getValue().trim();
    if (!userMessage || this.isGenerating || !this.activeFile) return;
    this.isGenerating = true;
    this.sendButton.disabled = true;
    const assistantPlaceholder = this.createTypingIndicator();
    const userMsg = {
      role: "user",
      content: userMessage,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    };
    this.messages.push(userMsg);
    await this.appendMessageToUI("user", userMessage);
    this.inputField.setValue("");
    this.adjustInputHeight();
    this.scrollToBottom();
    this.chatContainer.appendChild(assistantPlaceholder);
    this.scrollToBottom();
    let assistantResponse = "";
    const contentEl = assistantPlaceholder.querySelector(".nanogpt-message-content");
    try {
      const noteContent = await this.getNoteContent();
      const folderContext = await this.getFolderContext();
      let urls = this.extractUrls(userMessage);
      if (urls.length > 0) {
        const shouldScrape = await this.confirmScrapeUrls(urls);
        if (shouldScrape) {
          contentEl.empty();
          contentEl.createDiv({ cls: "nanogpt-edit-status", text: "Scraping URLs..." });
          const createdPaths = await this.createNotesFromScrape(urls, this.activeFile);
          assistantResponse = createdPaths.length > 0 ? `Scraped ${createdPaths.length} pages and saved them as notes.` : "No pages were scraped.";
          assistantPlaceholder.remove();
          await this.appendMessageToUI("assistant", assistantResponse);
          urls = [];
        } else {
          urls = [];
        }
      }
      if (assistantResponse === "" && this.chatMode === "edit") {
        const createNotes = this.parseCreateNotesCommand(userMessage);
        if (createNotes.length > 0) {
          contentEl.empty();
          contentEl.createDiv({ cls: "nanogpt-edit-status", text: "Creating notes..." });
          const createdPaths = await this.createNotesWithLinks(createNotes, this.activeFile);
          assistantResponse = createdPaths.length > 0 ? `Created ${createdPaths.length} notes and linked them in "${this.activeFile.basename}".` : "No notes were created.";
          assistantPlaceholder.remove();
          await this.appendMessageToUI("assistant", assistantResponse);
        } else {
          contentEl.empty();
          contentEl.createDiv({ cls: "nanogpt-edit-status", text: "Preparing edit preview..." });
          const systemPrompt = "You are an assistant that edits Obsidian notes. Return the full revised note in Markdown only.";
          const userPrompt = `Edit instructions:
${userMessage}

Original note:
${noteContent}${folderContext}`;
          let updatedContent = "";
          await this.client.streamChatCompletion(
            [
              { role: "system", content: systemPrompt },
              { role: "user", content: userPrompt }
            ],
            this.getChatModelId(),
            (chunk) => {
              updatedContent += chunk;
            },
            this.settings.temperature,
            this.settings.maxTokens
          );
          updatedContent = updatedContent.trim();
          if (!updatedContent) {
            throw new Error("No updated note returned");
          }
          this.pendingEditPreview = {
            file: this.activeFile,
            original: noteContent,
            updated: updatedContent
          };
          assistantResponse = `### Proposed edits

${updatedContent}

Use the buttons below to accept or reject these changes.`;
          assistantPlaceholder.remove();
          await this.appendMessageToUI("assistant", assistantResponse);
        }
      } else if (assistantResponse === "" && this.imageModelIds.has(this.currentModel)) {
        const imageResponse = await this.client.generateImage({
          prompt: userMessage,
          model: this.currentModel,
          size: this.settings.imageSize,
          quality: this.settings.imageQuality
        });
        const images = imageResponse.data.map((imageData, index) => {
          const imageDataUrl = imageData.b64_json ? `data:image/png;base64,${imageData.b64_json}` : imageData.url;
          if (!imageDataUrl) return "";
          return `![Generated image ${index + 1}](${imageDataUrl})`;
        }).filter(Boolean);
        assistantResponse = images.length > 0 ? `Generated images:

${images.join("\n\n")}` : "No images returned.";
        assistantPlaceholder.remove();
        await this.appendMessageToUI("assistant", assistantResponse);
      } else if (assistantResponse === "") {
        let searchContext = "";
        if (this.webSearchEnabled) {
          const statusEl = contentEl.createDiv({ cls: "nanogpt-search-status", text: "Searching web..." });
          try {
            const searchResults = await this.client.webSearch({
              query: userMessage,
              num_results: 3,
              provider: this.settings.webSearchProvider,
              options: this.settings.webSearchOptions
            });
            if (searchResults.results && searchResults.results.length > 0) {
              searchContext = `

Web Search Results for "${userMessage}":
` + searchResults.results.map((r, i) => `${i + 1}. [${r.title}](${r.url}): ${r.summary}`).join("\n");
            }
          } catch (e) {
            console.error("Web search failed", e);
          } finally {
            statusEl.remove();
          }
        }
        const systemPromptWithContext = `${this.settings.systemPrompt}

Context from active note "${this.activeFile.basename}":
${noteContent}${folderContext}${searchContext}`;
        await this.client.streamChatCompletion(
          [
            { role: "system", content: systemPromptWithContext },
            ...this.messages.filter((m) => m.role !== "system")
          ],
          this.getChatModelId(),
          (chunk) => {
            if (assistantResponse === "") {
              contentEl.empty();
            }
            assistantResponse += chunk;
            contentEl.innerHTML = this.formatMessageContent(assistantResponse);
            this.scrollToBottom();
          },
          this.settings.temperature,
          this.settings.maxTokens
        );
        assistantPlaceholder.remove();
        await this.appendMessageToUI("assistant", assistantResponse);
      }
      const assistantMsg = {
        role: "assistant",
        content: assistantResponse,
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        model: this.currentModel
      };
      this.messages.push(assistantMsg);
      if (this.activeFile) {
        await this.chatHistoryManager.saveChatHistory(this.activeFile, this.messages);
      }
    } catch (error) {
      console.error("Chat error:", error);
      new import_obsidian3.Notice(`Error: ${error.message}`);
      contentEl.setText(`Error: ${error.message}`);
      contentEl.addClass("nanogpt-error");
    } finally {
      this.isGenerating = false;
      this.sendButton.disabled = false;
      this.inputField.inputEl.focus();
    }
  }
  createTypingIndicator() {
    const messageEl = this.chatContainer.createDiv({
      cls: `nanogpt-message nanogpt-assistant`
    });
    const headerDiv = messageEl.createDiv({ cls: "nanogpt-message-header" });
    headerDiv.createSpan({ cls: "nanogpt-message-role", text: "NanoGPT" });
    const contentEl = messageEl.createDiv({ cls: "nanogpt-message-content" });
    const indicator = contentEl.createDiv({ cls: "nanogpt-typing-indicator" });
    indicator.createDiv({ cls: "nanogpt-dot" });
    indicator.createDiv({ cls: "nanogpt-dot" });
    indicator.createDiv({ cls: "nanogpt-dot" });
    return messageEl;
  }
  async clearChat() {
    if (!this.activeFile) return;
    this.messages = [];
    await this.chatHistoryManager.clearChatHistory(this.activeFile);
    await this.renderMessages();
    new import_obsidian3.Notice("Chat cleared");
  }
  adjustInputHeight() {
    const textarea = this.inputField.inputEl;
    textarea.style.height = "auto";
    textarea.style.height = Math.min(textarea.scrollHeight, 200) + "px";
  }
  scrollToBottom() {
    this.chatContainer.scrollTop = this.chatContainer.scrollHeight;
  }
};

// main.ts
var setGhostTextEffect = import_state.StateEffect.define();
var clearGhostTextEffect = import_state.StateEffect.define();
var GhostTextWidget = class extends import_view.WidgetType {
  constructor(text) {
    super();
    this.text = text;
  }
  toDOM() {
    const span = document.createElement("span");
    span.className = "nanogpt-ghost-text";
    span.textContent = this.text;
    return span;
  }
};
var ghostTextStateField = import_state.StateField.define({
  create: () => ({ text: "", pos: 0 }),
  update: (value, transaction) => {
    let next = value;
    for (const effect of transaction.effects) {
      if (effect.is(setGhostTextEffect)) {
        next = effect.value;
      }
      if (effect.is(clearGhostTextEffect)) {
        next = { text: "", pos: 0 };
      }
    }
    if (transaction.docChanged && next.text) {
      next = { ...next, pos: transaction.changes.mapPos(next.pos) };
    }
    return next;
  }
});
var ghostTextDecorations = import_view.EditorView.decorations.compute([ghostTextStateField], (state) => {
  const ghost = state.field(ghostTextStateField);
  if (!ghost.text) {
    return import_view.Decoration.none;
  }
  return import_view.Decoration.set([
    import_view.Decoration.widget({
      widget: new GhostTextWidget(ghost.text),
      side: 1
    }).range(ghost.pos)
  ]);
});
var ghostTextClearer = import_view.ViewPlugin.fromClass(
  class {
    update(update) {
      const hasSetEffect = update.transactions.some(
        (transaction) => transaction.effects.some(
          (effect) => effect.is(setGhostTextEffect)
        )
      );
      if (hasSetEffect) return;
      const ghost = update.state.field(ghostTextStateField);
      if (!ghost.text) return;
      if (update.docChanged || update.selectionSet) {
        update.view.dispatch({ effects: clearGhostTextEffect.of(null) });
      }
    }
  }
);
var acceptGhostText = (view) => {
  const ghost = view.state.field(ghostTextStateField);
  if (!ghost.text) return false;
  view.dispatch({
    changes: { from: ghost.pos, to: ghost.pos, insert: ghost.text },
    effects: clearGhostTextEffect.of(null)
  });
  return true;
};
var ghostTextExtension = [
  ghostTextStateField,
  ghostTextDecorations,
  ghostTextClearer,
  import_state.Prec.high(import_view.keymap.of([{ key: "Tab", run: acceptGhostText }]))
];
var NanoGPTPlugin = class extends import_obsidian7.Plugin {
  constructor() {
    super(...arguments);
    this.inlineAutocompleteTimer = null;
    this.inlineAutocompleteInFlight = false;
    this.inlineAutocompleteRequestId = 0;
    this.isApplyingAutocomplete = false;
  }
  async onload() {
    console.log("Loading NanoGPT Assistant plugin");
    await this.loadSettings();
    this.client = new NanoGPTClient(this.settings.apiKey, this.settings.baseUrl);
    this.chatHistoryManager = new ChatHistoryManager(this.app, this);
    this.imageManager = new ImageManager(this.app);
    this.registerEditorExtension(ghostTextExtension);
    this.registerView(
      VIEW_TYPE_CHAT,
      (leaf) => new ChatView(leaf, this.client, this.chatHistoryManager, this.settings)
    );
    this.addRibbonIcon("sparkles", "NanoGPT Chat", () => {
      this.activateChatView();
    });
    this.addSettingTab(new NanoGPTSettingTab(this.app, this));
    this.addCommand({
      id: "open-chat",
      name: "Open Chat",
      callback: () => {
        this.activateChatView();
      }
    });
    this.addCommand({
      id: "generate-summary",
      name: "Generate Summary",
      editorCallback: (editor, ctx) => {
        if (ctx.file) this.generateSummary(editor, ctx.file);
      }
    });
    this.addCommand({
      id: "expand-selection",
      name: "Expand Selection",
      editorCallback: (editor, ctx) => {
        if (ctx.file) this.expandSelection(editor, ctx.file);
      }
    });
    this.addCommand({
      id: "rewrite-text",
      name: "Rewrite Text",
      editorCallback: (editor, ctx) => {
        if (ctx.file) this.rewriteText(editor, ctx.file);
      }
    });
    this.addCommand({
      id: "explain-selection",
      name: "Explain Selection",
      editorCallback: (editor, ctx) => {
        if (ctx.file) this.explainSelection(editor, ctx.file);
      }
    });
    this.addCommand({
      id: "generate-image",
      name: "Generate Image",
      callback: () => {
        this.generateImage();
      }
    });
    this.addCommand({
      id: "generate-image-from-selection",
      name: "Generate Image from Selection",
      editorCallback: (editor) => {
        this.generateImageFromSelection(editor);
      }
    });
    this.addCommand({
      id: "web-search",
      name: "Web Search",
      callback: () => {
        this.webSearch();
      }
    });
    this.addCommand({
      id: "web-search-from-selection",
      name: "Web Search from Selection",
      editorCallback: (editor) => {
        this.webSearchFromSelection(editor);
      }
    });
    this.addCommand({
      id: "inline-autocomplete",
      name: "Inline Autocomplete",
      editorCallback: (editor, ctx) => {
        if (ctx.file) this.inlineAutocomplete(editor, ctx.file, false);
      }
    });
    this.addCommand({
      id: "edit-note-with-ai",
      name: "Edit Note with AI",
      editorCallback: (editor, ctx) => {
        if (ctx.file) this.editNoteWithAI(ctx.file);
      }
    });
    this.addCommand({
      id: "complete-note",
      name: "Complete Note",
      editorCallback: (editor, ctx) => {
        if (ctx.file) this.completeNote(editor, ctx.file);
      }
    });
    this.addCommand({
      id: "generate-outline",
      name: "Generate Outline",
      editorCallback: (editor, ctx) => {
        if (ctx.file) this.generateOutline(editor, ctx.file);
      }
    });
    this.registerEvent(
      this.app.workspace.on("editor-change", (editor, view) => {
        if (!this.settings.inlineAutocompleteEnabled) return;
        if (!(view instanceof import_obsidian7.MarkdownView)) return;
        if (!view.file) return;
        if (this.isApplyingAutocomplete) return;
        this.scheduleInlineAutocomplete(editor, view.file);
      })
    );
    console.log("NanoGPT Assistant plugin loaded");
  }
  async onunload() {
    console.log("Unloading NanoGPT Assistant plugin");
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.client.setApiKey(this.settings.apiKey);
    this.client.setBaseUrl(this.settings.baseUrl);
    this.client.invalidateCache();
  }
  async activateChatView() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE_CHAT);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      const rightLeaf = workspace.getRightLeaf(false);
      if (rightLeaf) {
        leaf = rightLeaf;
        await leaf.setViewState({ type: VIEW_TYPE_CHAT, active: true });
      }
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
    }
  }
  async generateSummary(editor, file) {
    await this.processTextCommand(editor, "Summarize the following text:", file);
  }
  async expandSelection(editor, file) {
    await this.processTextCommand(editor, "Expand on the following text:", file);
  }
  async rewriteText(editor, file) {
    await this.processTextCommand(editor, "Rewrite the following text:", file);
  }
  async explainSelection(editor, file) {
    await this.processTextCommand(editor, "Explain the following text in simple terms:", file);
  }
  async processTextCommand(editor, instruction, file) {
    const selectedText = editor.getSelection();
    if (!selectedText) {
      new import_obsidian7.Notice("Please select some text first");
      return;
    }
    new import_obsidian7.Notice("Processing...");
    const cursor = editor.getCursor();
    try {
      let response = "";
      const systemPrompt = `You are a helpful assistant. ${instruction}`;
      await this.client.streamChatCompletion(
        [
          { role: "system", content: systemPrompt },
          { role: "user", content: selectedText }
        ],
        this.settings.defaultModel,
        (chunk) => {
          response += chunk;
        },
        this.settings.temperature,
        this.settings.maxTokens
      );
      editor.replaceRange(response, cursor.from, cursor.to);
      new import_obsidian7.Notice("Complete!");
    } catch (error) {
      console.error("Text command error:", error);
      new import_obsidian7.Notice(`Error: ${error.message}`);
    }
  }
  generateImage() {
    const { ImageModal: ImageModal2 } = (init_ImageModal(), __toCommonJS(ImageModal_exports));
    new ImageModal2(
      this.app,
      this.client,
      this.imageManager,
      this.settings
    ).open();
  }
  async generateImageFromSelection(editor) {
    const selectedText = editor.getSelection();
    if (!selectedText) {
      new import_obsidian7.Notice("Please select some text first");
      return;
    }
    const { ImageModal: ImageModal2 } = (init_ImageModal(), __toCommonJS(ImageModal_exports));
    new ImageModal2(
      this.app,
      this.client,
      this.imageManager,
      this.settings,
      selectedText
    ).open();
  }
  webSearch() {
    const { WebSearchModal: WebSearchModal2 } = (init_WebSearchModal(), __toCommonJS(WebSearchModal_exports));
    new WebSearchModal2(
      this.app,
      this.client,
      this.settings
    ).open();
  }
  async webSearchFromSelection(editor) {
    const selectedText = editor.getSelection();
    if (!selectedText) {
      new import_obsidian7.Notice("Please select some text first");
      return;
    }
    const { WebSearchModal: WebSearchModal2 } = (init_WebSearchModal(), __toCommonJS(WebSearchModal_exports));
    new WebSearchModal2(
      this.app,
      this.client,
      this.settings,
      selectedText
    ).open();
  }
  async completeNote(editor, file) {
    const title = file.basename;
    if (!title) {
      new import_obsidian7.Notice("Note has no title");
      return;
    }
    new import_obsidian7.Notice("Generating note content...");
    const cursor = editor.getCursor();
    try {
      let response = "";
      await this.client.streamChatCompletion(
        [
          { role: "system", content: "You are a helpful assistant that writes comprehensive Obsidian notes in Markdown format." },
          { role: "user", content: `Write a complete Obsidian Markdown note about "${title}". Include an introduction, key points, examples, and a conclusion.` }
        ],
        this.settings.defaultModel,
        (chunk) => {
          response += chunk;
        },
        this.settings.temperature,
        this.settings.maxTokens
      );
      editor.replaceRange(response, cursor);
      new import_obsidian7.Notice("Note completed!");
    } catch (error) {
      console.error("Note completion error:", error);
      new import_obsidian7.Notice(`Error: ${error.message}`);
    }
  }
  scheduleInlineAutocomplete(editor, file) {
    if (this.inlineAutocompleteTimer) {
      window.clearTimeout(this.inlineAutocompleteTimer);
    }
    this.inlineAutocompleteTimer = window.setTimeout(() => {
      this.inlineAutocomplete(editor, file, true);
    }, this.settings.inlineAutocompleteDelayMs);
  }
  setGhostText(editor, cursor, text) {
    const cm = editor.cm;
    if (!cm || typeof cm.dispatch !== "function") {
      return false;
    }
    const pos = editor.posToOffset(cursor);
    cm.dispatch({
      effects: setGhostTextEffect.of({ text, pos })
    });
    return true;
  }
  clearGhostText(editor) {
    const cm = editor.cm;
    if (!cm || typeof cm.dispatch !== "function") {
      return;
    }
    cm.dispatch({
      effects: clearGhostTextEffect.of(null)
    });
  }
  async inlineAutocomplete(editor, file, silent = false) {
    if (this.inlineAutocompleteInFlight) return;
    if (editor.somethingSelected()) return;
    const cursor = editor.getCursor();
    const lineText = editor.getLine(cursor.line);
    const linePrefix = lineText.slice(0, cursor.ch);
    const lineSuffix = lineText.slice(cursor.ch);
    if (lineSuffix.trim().length > 0) return;
    if (linePrefix.trim().length < 3) return;
    const requestId = ++this.inlineAutocompleteRequestId;
    if (!silent) {
      new import_obsidian7.Notice("Generating autocomplete...");
    }
    this.inlineAutocompleteInFlight = true;
    this.clearGhostText(editor);
    try {
      const fullText = editor.getValue();
      const cursorOffset = editor.posToOffset(cursor);
      const start = Math.max(0, cursorOffset - 2500);
      const end = Math.min(fullText.length, cursorOffset + 800);
      const contextSnippet = fullText.slice(start, end);
      const systemPrompt = "You are an inline autocomplete engine for Obsidian notes. Return only the continuation text to insert at the cursor.";
      const userPrompt = `Note title: ${file.basename}

Context around cursor:
${contextSnippet}

Current line:
${lineText}
Prefix before cursor:
${linePrefix}
Suffix after cursor:
${lineSuffix}

Provide the continuation to insert.`;
      let completion = "";
      await this.client.streamChatCompletion(
        [
          { role: "system", content: systemPrompt },
          { role: "user", content: userPrompt }
        ],
        this.settings.defaultModel,
        (chunk) => {
          completion += chunk;
        },
        this.settings.temperature,
        Math.min(this.settings.maxTokens, 400)
      );
      if (requestId !== this.inlineAutocompleteRequestId) return;
      const currentCursor = editor.getCursor();
      const currentLine = editor.getLine(cursor.line);
      if (currentCursor.line !== cursor.line || currentCursor.ch !== cursor.ch) return;
      if (!currentLine.startsWith(linePrefix)) return;
      const cleanedCompletion = completion.replace(/^\s+/, "").trimEnd();
      if (!cleanedCompletion) {
        if (!silent) new import_obsidian7.Notice("No completion returned");
        return;
      }
      const ghostApplied = this.setGhostText(editor, cursor, cleanedCompletion);
      if (!ghostApplied) {
        this.isApplyingAutocomplete = true;
        editor.replaceRange(cleanedCompletion, cursor);
        this.isApplyingAutocomplete = false;
        if (!silent) new import_obsidian7.Notice("Autocomplete inserted");
        return;
      }
      if (!silent) {
        new import_obsidian7.Notice("Autocomplete ready (Tab to accept)");
      }
    } catch (error) {
      console.error("Autocomplete error:", error);
      if (!silent) {
        new import_obsidian7.Notice(`Error: ${error.message}`);
      }
    } finally {
      this.inlineAutocompleteInFlight = false;
    }
  }
  async generateOutline(editor, file) {
    const title = file.basename;
    if (!title) {
      new import_obsidian7.Notice("Note has no title");
      return;
    }
    new import_obsidian7.Notice("Generating outline...");
    const cursor = editor.getCursor();
    try {
      let response = "";
      await this.client.streamChatCompletion(
        [
          { role: "system", content: "You are a helpful assistant that creates structured outlines in Markdown format." },
          { role: "user", content: `Create a detailed outline for a note about "${title}". Use Markdown headings and bullet points.` }
        ],
        this.settings.defaultModel,
        (chunk) => {
          response += chunk;
        },
        this.settings.temperature,
        this.settings.maxTokens
      );
      editor.replaceRange(response, cursor);
      new import_obsidian7.Notice("Outline generated!");
    } catch (error) {
      console.error("Outline generation error:", error);
      new import_obsidian7.Notice(`Error: ${error.message}`);
    }
  }
  editNoteWithAI(file) {
    const { EditNoteModal: EditNoteModal2 } = (init_EditNoteModal(), __toCommonJS(EditNoteModal_exports));
    new EditNoteModal2(
      this.app,
      this.client,
      this.settings,
      file
    ).open();
  }
};
var NanoGPTSettingTab = class extends import_obsidian7.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian7.Setting(containerEl).setName("API Key").setDesc("Your NanoGPT API key").addText((text) => {
      text.inputEl.type = "password";
      text.setPlaceholder("Enter your API key").setValue(this.plugin.settings.apiKey).onChange(async (value) => {
        this.plugin.settings.apiKey = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian7.Setting(containerEl).setName("Base URL").setDesc("NanoGPT API base URL").addText(
      (text) => text.setPlaceholder("https://nano-gpt.com/api/v1").setValue(this.plugin.settings.baseUrl).onChange(async (value) => {
        this.plugin.settings.baseUrl = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian7.Setting(containerEl).setName("Default Model").setDesc("Default model to use for chat and text generation").addText(
      (text) => text.setPlaceholder("zai-org/glm-4.7").setValue(this.plugin.settings.defaultModel).onChange(async (value) => {
        this.plugin.settings.defaultModel = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian7.Setting(containerEl).setName("Show Subscription Only").setDesc("Only show models included in subscription").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.subscriptionOnly).onChange(async (value) => {
        this.plugin.settings.subscriptionOnly = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian7.Setting(containerEl).setName("System Prompt").setDesc("Default system prompt for chat").addTextArea(
      (text) => text.setPlaceholder("You are a helpful assistant.").setValue(this.plugin.settings.systemPrompt).onChange(async (value) => {
        this.plugin.settings.systemPrompt = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian7.Setting(containerEl).setName("Temperature").setDesc("Controls randomness (0.0 - 2.0)").addSlider(
      (slider) => slider.setLimits(0, 2, 0.1).setValue(this.plugin.settings.temperature).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.temperature = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian7.Setting(containerEl).setName("Max Tokens").setDesc("Maximum tokens to generate").addText(
      (text) => text.setPlaceholder("2048").setValue(this.plugin.settings.maxTokens.toString()).onChange(async (value) => {
        const num = parseInt(value);
        if (!isNaN(num)) {
          this.plugin.settings.maxTokens = num;
          await this.plugin.saveSettings();
        }
      })
    );
    new import_obsidian7.Setting(containerEl).setName("Inline Autocomplete").setDesc("Suggest completions as you type").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.inlineAutocompleteEnabled).onChange(async (value) => {
        this.plugin.settings.inlineAutocompleteEnabled = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian7.Setting(containerEl).setName("Autocomplete Delay (ms)").setDesc("Wait time after typing before suggesting").addText(
      (text) => text.setPlaceholder("700").setValue(this.plugin.settings.inlineAutocompleteDelayMs.toString()).onChange(async (value) => {
        const num = parseInt(value);
        if (!isNaN(num)) {
          this.plugin.settings.inlineAutocompleteDelayMs = num;
          await this.plugin.saveSettings();
        }
      })
    );
    new import_obsidian7.Setting(containerEl).setName("Folder Context").setDesc("Include other notes in the same folder").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.folderContextEnabled).onChange(async (value) => {
        this.plugin.settings.folderContextEnabled = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian7.Setting(containerEl).setName("Folder Context Max Notes").setDesc("Maximum notes to include for context").addText(
      (text) => text.setPlaceholder("5").setValue(this.plugin.settings.folderContextMaxFiles.toString()).onChange(async (value) => {
        const num = parseInt(value);
        if (!isNaN(num)) {
          this.plugin.settings.folderContextMaxFiles = num;
          await this.plugin.saveSettings();
        }
      })
    );
    new import_obsidian7.Setting(containerEl).setName("Folder Context Max Characters").setDesc("Limit total context size").addText(
      (text) => text.setPlaceholder("8000").setValue(this.plugin.settings.folderContextMaxChars.toString()).onChange(async (value) => {
        const num = parseInt(value);
        if (!isNaN(num)) {
          this.plugin.settings.folderContextMaxChars = num;
          await this.plugin.saveSettings();
        }
      })
    );
    new import_obsidian7.Setting(containerEl).setName("Image Size").setDesc("Default size for generated images").addDropdown(
      (dropdown) => dropdown.addOptions({
        "256x256": "256x256",
        "512x512": "512x512",
        "1024x1024": "1024x1024",
        "1536x1024": "1536x1024",
        "1024x1536": "1024x1536"
      }).setValue(this.plugin.settings.imageSize).onChange(async (value) => {
        this.plugin.settings.imageSize = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian7.Setting(containerEl).setName("Image Quality").setDesc("Default quality for generated images").addDropdown(
      (dropdown) => dropdown.addOptions({
        "standard": "Standard",
        "hd": "HD"
      }).setValue(this.plugin.settings.imageQuality).onChange(async (value) => {
        this.plugin.settings.imageQuality = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian7.Setting(containerEl).setName("Web Search Results").setDesc("Number of results to return").addText(
      (text) => text.setPlaceholder("5").setValue(this.plugin.settings.webSearchNumResults.toString()).onChange(async (value) => {
        const num = parseInt(value);
        if (!isNaN(num)) {
          this.plugin.settings.webSearchNumResults = num;
          await this.plugin.saveSettings();
        }
      })
    );
    new import_obsidian7.Setting(containerEl).setName("Web Search Provider").setDesc("Provider name from NanoGPT web search docs").addText(
      (text) => text.setPlaceholder("tavily").setValue(this.plugin.settings.webSearchProvider).onChange(async (value) => {
        this.plugin.settings.webSearchProvider = value.trim();
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian7.Setting(containerEl).setName("Web Search Options (JSON)").setDesc("Optional provider-specific options in JSON").addTextArea(
      (text) => text.setPlaceholder('{"search_depth": "basic"}').setValue(this.plugin.settings.webSearchOptions).onChange(async (value) => {
        this.plugin.settings.webSearchOptions = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian7.Setting(containerEl).setName("Include Citations").setDesc("Include citation section in web search results").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.includeCitations).onChange(async (value) => {
        this.plugin.settings.includeCitations = value;
        await this.plugin.saveSettings();
      })
    );
  }
};
